# 顺序查找（The sequential search）

当一堆数据存放在一个列表（list）里面，每个数据都有一个位置（position），而且这个位置是有顺序的，比如说 `list[2]`，就表示我们要访问位置为2，也就是数组的第3个数据。当我们在这样一个有顺序的列表中，查找某一个数据时，这个过程我们称为「顺序查找」。顺序查找最重要的东西是什么？就是位置，我们也称为下标。

看下面这个列表：



![](https://ws1.sinaimg.cn/large/006tKfTcgy1fnhmshd56nj30bs02iq2v.jpg)

当我们要在这个列表中找一个数据时，是从左到右依次查询，当把所有位置的数据都查找一边之后，如果最终还是没找到想要的数据，那就可以断定，这个数据不在这个列表中。

下面，我们用python，实现一个顺序查找的方法：

```python
def sequentialSearch(alist, item):
  pos = 0
  found = False
  
  while pos < len(alist) and not found
  	if alist[post] == item
    	found = True
    else
    	pos = pos + 1

  return found

testlist = [1, 2, 32, 8, 17, 19, 42, 13, 0]
print(sequentialSearch(testlist, 3)) // False
print(sequentialSearch(testlist, 13)) // True
```

## 分析顺序查找的效率

我们先来思考一个问题 — 如何分析一个算法的好坏呢？首先，我们应该找出一个最小单元，然后根据这个最小单元的执行次数，来间接地推断出一个算法的效率。对于顺序查找，最小单元就是**比较**「你要找的数据」和「当前位置的数据」是不是相等的这个操作。换句话说，分析一个顺序查找算法的效率，就是分析「比较次数」的多少。如果「要查找的数据」在列表，那么，我们需要比较的次数，刚好就等于这个数据在列表的位置。

通常来时，分析一个算法，可以从三种情况入手：`Best Case`, `Worst Case` 和 `Average Case`。

Best Case。当「要查找的数据」刚好位于列表的第一个，那就是最好的情况了，只比较了1次就结束了。

Worst Case，当「要查找的数据」不在列表中，那就是最糟糕的情况，比较次数就是列表数据的个数。

Average Case，当「要查找的数据」刚刚好在列表的中间，那就是平均的（或者说是普通的、平常的）情况。比较次数是 `n/2`，一般来说，我们是通过Average Case，来推断一个算法的复杂度。你可能会说，那这个算法的复杂度就是O(n/2)，但正确的结果是O(n)。因为，当n越来越大的时候，这个系数（1/2），对于整个过程的性能而言，可以忽略不计，最终我们能得到的近似值就是n，所以，我们称它的算法复杂的为O(n)。为了更好地解释这个，我再举两个例子：

假设一个算法，用函数来表示是 `T(n) = n + 1`，当n很小的时候，1的是不可以忽略的。当n变大，而且变得超大的时候，n就可以忽略不计的，我们可以这么认为：在一个大数量级的情况下，这个累加算法的近似值为 `T(n) = n`，我们把它表示为O(n)。

假如一个算法用函数来表示为：`T(n)=5n^2+27n+1005`，当n变大，而且变得很大的数量级之后，`5n2` 会超级大，所以27n和1005可以忽略不计。还有一点值得注意的是，如果n变成很大的数量级，其实 `5n^2` 中的5也可以忽略不计。你可能会说，那么可能忽略不计啊，一个超级大的数据，乘5和不乘5，对结果影响的很大的。是的，这个说法并没有错误，这是从结果的角度来分析。但是，**评价算法的优劣并不关注结果，而是这个过程所消耗的资源**。也就是，当n超级大的时候，n2已经非常复杂了，复杂到可以忽略 `5 x n^2` 的计算的过程。所以，它的算法近似值为Q(n^2)。

所以，你现在就应该能明白，为什么 `T(n) = n/2` 的算法复杂度是O(n)了吧？希望我举的例子能帮助到你的理解。

好，整理一下，我们得到下面这张表：

|  Case   | Best Case | Worst Case | Average Case |
| :-----: | :-------: | :--------: | :----------: |
| 数据在列表中  |     1     |     n      |     n/2      |
| 数据不在列表中 |     n     |     n      |      n       |

我们上面讨论的列表，都是无序列表，那如果是有序列表，查找元素的时候，会不会更快呢？

假设我们有一个列表，里面的数据是以上升顺序（ascending order）来排序的，也就是从低到高。当「要查找的数据」在列表中，所需要的查找次数和无需列表一样，都是等于这个数据在列表的位置。然而，当「要查找的数据」不在列表中，那就有不一样了。举个例子：

![](https://ws2.sinaimg.cn/large/006tKfTcgy1fnhnuqpemrj30c902iq2v.jpg)

假设当我们要找到数据是50，当我们一步一步查找到54的时候，发现，咦，因为我们当前这个列表是有序的，现在我比较的数据是54，而54显然已经大于50，那么，我们没有必要继续往下查询了，直接可以下结论：50不在这个列表中。

下面，我们用python，实现一个有序列表的方法：

```python
def orderedSequentialSearch(alist, item):
    pos = 0
    found = False
    stop = False
    
    while pos < len(alist) and not found and not stop
    	if alist[pos] == item
        	found = True
        else
        	if alist[pos] > item
            	stop = True
            else
            	pos = pos + 1
         
    return found

testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42,]
print(orderedSequentialSearch(testlist, 3)) // False
print(orderedSequentialSearch(testlist, 13)) // True
```

同样，我们分析得出三种Case的结果：

|  Case   | Best Case | Worst Case | Average Case |
| :-----: | :-------: | :--------: | :----------: |
| 数据在列表中  |     1     |     n      |     n/2      |
| 数据不在列表中 |     1     |     n      |     n/2      |

然而，这个算法是复杂度依旧是O(n)。也就是说，只有当数据不在一个有序列表中的时候，顺序查询的效率才会得到提高。

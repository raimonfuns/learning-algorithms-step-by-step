# 二分查找（The Binary Search）

上一篇我们介绍了对有序列表和无序列表进行顺序查找的算法，今天，针对有序列表的查找，介绍一个种新的算法 — 二分查找。在对有序列表的顺序查找中，当比较第一个数据时，如果发现它不是我们想要的数据，那么，在最坏的情况下，我们可能要查找 `n - 1`次才能结束。今天，我们的主角，也就是「二分查找」，相对于顺序查找而言，二分查找不是按照顺序、一个一个地一次查找，而是每次都从中间开始查找。

二分查找是这样的，第一次，我们取中间的数据来比较，如果这个数据刚刚好是我们要找的，那就完事了。否则，就会有两种情况：当前这个被我们拿来比较的数据，要么大于我们要找的数据，要么小于我们要找的数据。如果是「大于」的情况，那么，我们拿刀往中间一砍，因为我们比较的是有序列表，所以，左边的数据，肯定都小于我们要找的数据，完全可以忽略掉，不要了。相反，如果是「小于」的情况，那就把右边的数据扔掉。然后，在留下的那堆数据里面，继续采用相同的方法，从中间开始，继续砍，直到找到目标数据，如果最终只剩下一个数据，还是没找到，那就说明，我们要找的数据，不在列表中。

 举个栗子，看下面这张图片

![](http://p2mvd0t5x.bkt.clouddn.com/2018-01-16-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-16%20%E4%B8%8B%E5%8D%8810.20.04.png)

假设我们要找的数据是54。列表的总数是10，由于列表的位置（position）是从0开始的，所以，我们把总数「看作」9。好，让我们开始吧，第一次，切一半，`9 / 2 = 4.5` ，取值得到4，对应的数据是44，因为 `44 < 54`，所以，去左边，留右边。第二次，`（5 + 9） / 2`，得到7，对应的数据是65，因为 `65 > 54`，留左边，去右边。第三次，`（ 5 + 8） / 2`，得到6，对应的数据是54，bingo!!!，找到啦，算法结束。

下面，我们用python来实现二分查找算法：

```python
def binarySearch(alist, item):
    first = 0
    last = len(alist)-1
    found = False
    
    while first <= last and not found:
    	midpoint = (first + last)//2
        if alist[midpoint] == item:
            found = True
        else:
        	if item < alist[midpoint]:
            	last = midpoint-1
            else:
            	first = midpoint+1
    
	return found

testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42,]
print(binarySearch(testlist, 3)) // False
print(binarySearch(testlist, 13)) // True
```

## 分析二分查找算法的效率

回忆一下，我们是怎么分析一个算法的效率的？首先，找出最小单元，然后根据最小单元的执行次数作为算法的性能指标。执行次数越多，算法效率越低。

当一个列表有`n`个数据，比较1次之后，剩下`n/2`，比较2次之后，剩下`n/4`，3次之后，剩下`n/8`，以此类推。于是，我们可以得到下面这张表：

| 比较次数 | 剩余的数据 |
| :--: | :---: |
|  1   |  n/2  |
|  2   |  n/4  |
|  3   |  n/8  |
| ...  |       |
|  i   | n/2^i |

想象一下，当我们不断地切一个列表，切切切，最终，只会剩下一个数据，对吧。于是，我们可以推导出：

`n/2^i = 1`，即`i = logn`，这就是`Worst case`，而worst case就是我们所说的算法复杂度，所以，我们可以称这二分查找算法的复杂度是`O(logn)`。
